ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(leaflet)
library(extrafont)
library(tidygeocoder)
library(classInt)
library(purrr)
library(viridis)
options(scipen = 999)
# font_import()
# loadfonts()
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(leaflet)
library(extrafont)
library(tidygeocoder)
library(classInt)
library(purrr)
library(viridis)
options(scipen = 999)
# font_import()
# loadfonts()
housing <- st_read("./Data/ExistingHDBDissolved.geojson")
sg <- st_read("./Data/mp2019subzones.geojson")
str(housing)
str(sg)
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
intersections$intersected_area <- st_area(intersections)
sg <- st_join(sg, intersections[, c("intersected_area")], join = st_intersects)
sg$proportion_intersection <- sg$intersected_area / sg$area
sg$proportion_intersection[is.na(sg$proportion_intersection)] <- 0
sg$proportion_intersection <- as.numeric(sg$proportion_intersection)
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
# Ensure your sf object is in the correct format
sg <- st_as_sf(sg)
# Create a hexagonal grid covering the bounding box of 'sg'
hex_grid <- st_make_grid(sg, cellsize = 0.01, square = FALSE)  # Adjust cellsize as needed
# Convert hex grid to sf object
hex_grid <- st_sf(geometry = hex_grid)
# Calculate area of hexagons
hex_grid$area <- st_area(hex_grid)
# Initialize column for intersected area
hex_grid$intersected_area <- 0
# Calculate intersections and areas for each hexagon
for (i in 1:nrow(hex_grid)) {
intersection <- st_intersection(hex_grid[i, ], sg)
hex_grid$intersected_area[i] <- sum(st_area(intersection))
}
st_crs(sg)
# Ensure your sf object is in the correct format
sg <- st_as_sf(sg)
# Create a hexagonal grid covering the bounding box of 'sg'
hex_grid <- st_make_grid(sg, cellsize = 1, square = FALSE)  # Adjust cellsize as needed
# Convert hex grid to sf object
hex_grid <- st_sf(geometry = hex_grid)
# Calculate area of hexagons
hex_grid$area <- st_area(hex_grid)
# Initialize column for intersected area
hex_grid$intersected_area <- 0
# Calculate intersections and areas for each hexagon
for (i in 1:nrow(hex_grid)) {
intersection <- st_intersection(hex_grid[i, ], sg)
hex_grid$intersected_area[i] <- sum(st_area(intersection))
}
# Calculate the proportion of intersection for each hexagon
hex_grid$proportion_intersection <- hex_grid$intersected_area / hex_grid$area
# Replace NA values with 0 for hexagons that don't intersect
hex_grid$proportion_intersection[is.na(hex_grid$proportion_intersection)] <- 0
# Create the choropleth map
ggplot(data = hex_grid) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
View(hex_grid)
# Ensure your sf object is in the correct format
sg <- st_as_sf(sg)
# Create a hexagonal grid covering the bounding box of 'sg'
hex_grid <- st_make_grid(sg, cellsize = .1, square = FALSE)  # Adjust cellsize as needed
# Convert hex grid to sf object
hex_grid <- st_sf(geometry = hex_grid)
# Calculate area of hexagons
hex_grid$area <- st_area(hex_grid)
# Initialize column for intersected area
hex_grid$intersected_area <- 0
# Calculate intersections and areas for each hexagon
for (i in 1:nrow(hex_grid)) {
intersection <- st_intersection(hex_grid[i, ], sg)
hex_grid$intersected_area[i] <- sum(st_area(intersection))
}
# Calculate the proportion of intersection for each hexagon
hex_grid$proportion_intersection <- hex_grid$intersected_area / hex_grid$area
# Replace NA values with 0 for hexagons that don't intersect
hex_grid$proportion_intersection[is.na(hex_grid$proportion_intersection)] <- 0
names(hex_grid)
ggplot(data = hex_grid) +
geom_sf(aes(fill = intersected_area), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
ggplot(data = hex_grid) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
head(hex_grid)
hex_grid$proportion_intersection <- as.numeric(hex_grid$proportion_intersection)
ggplot(data = hex_grid) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
intersecting_hexagons <- st_intersects(hex_grid, sg, sparse = FALSE)  # returns a logical matrix
hex_grid_filtered <- hex_grid[rowSums(intersecting_hexagons) > 0, ]  # keep only those that intersect
ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
# Ensure your sf object is in the correct format
sg <- st_as_sf(sg)
# Create a hexagonal grid covering the bounding box of 'sg'
hex_grid <- st_make_grid(sg, cellsize = .05, square = FALSE)  # Adjust cellsize as needed
# Convert hex grid to sf object
hex_grid <- st_sf(geometry = hex_grid)
# Calculate area of hexagons
hex_grid$area <- st_area(hex_grid)
# Initialize column for intersected area
hex_grid$intersected_area <- 0
# Calculate intersections and areas for each hexagon
for (i in 1:nrow(hex_grid)) {
intersection <- st_intersection(hex_grid[i, ], sg)
hex_grid$intersected_area[i] <- sum(st_area(intersection))
}
# Calculate the proportion of intersection for each hexagon
hex_grid$proportion_intersection <- hex_grid$intersected_area / hex_grid$area
# Replace NA values with 0 for hexagons that don't intersect
hex_grid$proportion_intersection[is.na(hex_grid$proportion_intersection)] <- 0
hex_grid$proportion_intersection <- as.numeric(hex_grid$proportion_intersection)
intersecting_hexagons <- st_intersects(hex_grid, sg, sparse = FALSE)  # returns a logical matrix
hex_grid_filtered <- hex_grid[rowSums(intersecting_hexagons) > 0, ]  # keep only those that intersect
ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(leaflet)
library(extrafont)
library(tidygeocoder)
library(classInt)
library(purrr)
library(viridis)
options(scipen = 999)
# font_import()
# loadfonts()
housing <- st_read("./Data/ExistingHDBDissolved.geojson")
sg <- st_read("./Data/mp2019subzones_mainland.geojson")
str(housing)
str(sg)
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
intersections$intersected_area <- st_area(intersections)
sg <- st_join(sg, intersections[, c("intersected_area")], join = st_intersects)
sg$proportion_intersection <- sg$intersected_area / sg$area
sg$proportion_intersection[is.na(sg$proportion_intersection)] <- 0
sg$proportion_intersection <- as.numeric(sg$proportion_intersection)
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
# Ensure your sf object is in the correct format
sg <- st_as_sf(sg)
# Create a hexagonal grid covering the bounding box of 'sg'
hex_grid <- st_make_grid(sg, cellsize = .05, square = FALSE)  # Adjust cellsize as needed
# Convert hex grid to sf object
hex_grid <- st_sf(geometry = hex_grid)
# Calculate area of hexagons
hex_grid$area <- st_area(hex_grid)
# Initialize column for intersected area
hex_grid$intersected_area <- 0
# Calculate intersections and areas for each hexagon
for (i in 1:nrow(hex_grid)) {
intersection <- st_intersection(hex_grid[i, ], sg)
hex_grid$intersected_area[i] <- sum(st_area(intersection))
}
# Calculate the proportion of intersection for each hexagon
hex_grid$proportion_intersection <- hex_grid$intersected_area / hex_grid$area
# Replace NA values with 0 for hexagons that don't intersect
hex_grid$proportion_intersection[is.na(hex_grid$proportion_intersection)] <- 0
hex_grid$proportion_intersection <- as.numeric(hex_grid$proportion_intersection)
intersecting_hexagons <- st_intersects(hex_grid, sg, sparse = FALSE)  # returns a logical matrix
hex_grid_filtered <- hex_grid[rowSums(intersecting_hexagons) > 0, ]  # keep only those that intersect
ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
custom_palette <- c("#d1eee9", "#a3d6d6", "#7bbac2", "#5a9baa", "#3f798e", "#2a5674")
ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_gradientn(colors = custom_palette, na.value = "lightgrey") +  # Use the custom color palette
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(leaflet)
library(extrafont)
library(tidygeocoder)
library(classInt)
library(purrr)
library(viridis)
options(scipen = 999)
# font_import()
# loadfonts()
housing <- st_read("./Data/ExistingHDBDissolved.geojson")
sg <- st_read("./Data/mp2019subzones_mainland.geojson")
str(housing)
str(sg)
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
intersections$intersected_area <- st_area(intersections)
sg <- st_join(sg, intersections[, c("intersected_area")], join = st_intersects)
sg$proportion_intersection <- sg$intersected_area / sg$area
sg$proportion_intersection[is.na(sg$proportion_intersection)] <- 0
sg$proportion_intersection <- as.numeric(sg$proportion_intersection)
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
# Ensure your sf object is in the correct format
sg <- st_as_sf(sg)
# Create a hexagonal grid covering the bounding box of 'sg'
hex_grid <- st_make_grid(sg, cellsize = .02, square = FALSE)  # Adjust cellsize as needed
# Convert hex grid to sf object
hex_grid <- st_sf(geometry = hex_grid)
# Calculate area of hexagons
hex_grid$area <- st_area(hex_grid)
# Initialize column for intersected area
hex_grid$intersected_area <- 0
# Calculate intersections and areas for each hexagon
for (i in 1:nrow(hex_grid)) {
intersection <- st_intersection(hex_grid[i, ], sg)
hex_grid$intersected_area[i] <- sum(st_area(intersection))
}
# Calculate the proportion of intersection for each hexagon
hex_grid$proportion_intersection <- hex_grid$intersected_area / hex_grid$area
# Replace NA values with 0 for hexagons that don't intersect
hex_grid$proportion_intersection[is.na(hex_grid$proportion_intersection)] <- 0
hex_grid$proportion_intersection <- as.numeric(hex_grid$proportion_intersection)
intersecting_hexagons <- st_intersects(hex_grid, sg, sparse = FALSE)  # returns a logical matrix
hex_grid_filtered <- hex_grid[rowSums(intersecting_hexagons) > 0, ]  # keep only those that intersect
ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
custom_palette <- c("#d1eee9", "#a3d6d6", "#7bbac2", "#5a9baa", "#3f798e", "#2a5674")
ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_gradientn(colors = custom_palette, na.value = "lightgrey") +  # Use the custom color palette
labs(title = "Proportion of Intersection with Housing (Hexagonal Representation)",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
custom_palette <- c("#d1eee9", "#a3d6d6", "#7bbac2", "#5a9baa", "#3f798e", "#2a5674")
plot4 <- ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +
scale_fill_gradientn(colors = custom_palette, na.value = "lightgrey") +
labs(title = "Going Public: Proportion of Public Housing by Planning Subzones",
fill = "West side best side?") +  # Add title and legend label
annotate(
"text", x = 104.052232, y = 1.2,
label = "30DayMapChallenge\nDay #3\nPlayful Polygons\nByron",
color = "#7f8181", size = 3, hjust = 1, vjust = 1,
family = "Lato"
) +
annotate(
"text", x = 103.609410, y = 1.192789,
label = "",
color = "#7f8181", size = 2, hjust = 0, vjust = 1,
family = "Lato"
) +
theme(
plot.title = element_text(size = 14, face = "bold", family = "Lato Black"),
axis.title = element_blank(),
axis.text = element_blank(),
panel.grid = element_blank()
)
plot4
custom_palette <- c("#d1eee9", "#a3d6d6", "#7bbac2", "#5a9baa", "#3f798e", "#2a5674")
plot4 <- ggplot(data = hex_grid_filtered) +
geom_sf(aes(fill = proportion_intersection), color = NA) +
scale_fill_gradientn(colors = custom_palette, na.value = "lightgrey") +
labs(title = "Going Public: Proportion of Public Housing by Planning Subzones",
fill = "West side best side?") +  # Add title and legend label
annotate(
"text", x = 104.052232, y = 1.2,
label = "30DayMapChallenge\nDay #3\nPlayful Polygons\nByron",
color = "#7f8181", size = 3, hjust = 1, vjust = 1,
family = "Lato"
) +
annotate(
"text", x = 103.609410, y = 1.192789,
label = "",
color = "#7f8181", size = 2, hjust = 0, vjust = 1,
family = "Lato"
) +
theme(
plot.title = element_text(size = 14, face = "bold", family = "Lato Black"),
axis.title = element_blank(),
axis.text = element_blank(),
panel.grid = element_blank(),
panel.background = element_blank(),  # Remove the panel background
plot.background = element_blank()     # Remove the plot background
)
plot4
View(hex_grid_filtered)
housing <- st_read("./Data/ExistingHDBDissolved.geojson")
sg <- st_read("./Data/mp2019subzones_mainland.geojson")
str(housing)
str(sg)
View(sg)
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
intersections$intersected_area <- st_area(intersections)
sg <- st_join(sg, intersections[, c("intersected_area")], join = st_intersects)
sg$proportion_intersection <- sg$intersected_area / sg$area
sg$proportion_intersection[is.na(sg$proportion_intersection)] <- 0
sg$proportion_intersection <- as.numeric(sg$proportion_intersection)
View(sg)
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
ggplot() +
geom_sf(data = sg, fill = NA, color = "blue") +
geom_sf(data = housing, fill = NA, color = "red") +
geom_sf(data = intersections, fill = "green", alpha = 0.5) +
theme_minimal()
View(intersections)
ggplot() +
geom_sf(data = intersections, fill = "green", alpha = 0.5) +
theme_minimal()
View(intersections)
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
# intersections$intersected_area <- st_area(intersections)
sg <- st_join(sg, intersections[, c("area")], join = st_intersects)
sg$proportion_intersection <- sg$intersected_area / sg$area
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
# intersections$intersected_area <- st_area(intersections)
intersections$overlap <- intersections$area
sg <- st_join(sg, intersections[, c("overlap")], join = st_intersects)
sg$proportion_intersection <- sg$overlap / sg$area
sg$proportion_intersection[is.na(sg$proportion_intersection)] <- 0
sg$proportion_intersection <- as.numeric(sg$proportion_intersection)
ggplot(data = sg) +
geom_sf(aes(fill = proportion_intersection), color = NA) +  # Fill based on proportion_intersection
scale_fill_viridis_c(option = "C", na.value = "lightgrey") +  # Use a color scale
labs(title = "Proportion of Intersection with Housing",
fill = "Proportion\nof Intersection") +  # Add title and legend label
theme_minimal() +  # Use a minimal theme
theme(legend.position = "right")  # Position the legend on the right
View(sg)
sg <- st_as_sf(sg)
housing <- st_as_sf(housing)
invalid_geometries <- !st_is_valid(sg)
# Print out the invalid geometries if any
if (any(invalid_geometries)) {
print(paste("Invalid geometries found in indices:", which(invalid_geometries)))
# Make geometries valid
sg$geometry <- st_make_valid(sg$geometry)
print("Invalid geometries have been fixed.")
} else {
print("All geometries are valid.")
}
sg$area <- st_area(sg)
intersections <- st_intersection(sg, housing)
